//create a set from array of string
//loop through the array of set
//get frquency from text

interface HoofNode {
  freq: number;
  char: string;
  left: any;
  right: any;
}

let hoofCodeMap = new Map();
let root: any = null;
let decoded_string = "";

function buildHoffTreeAndGenerateHoofCode(frqMapArr: HoofNode[]) {
  // sort the arr so its easy to pick lowest minimum yay!!
  frqMapArr.sort((a, b) => {
    return a.freq - b.freq;
  });

  while (frqMapArr.length > 1) {
    //extract first min
    let x = frqMapArr[0];
    frqMapArr.shift();

    let y = frqMapArr[0];
    frqMapArr.shift();

    // create a new node and assign appropriate left and right node with sum of freq's
    let newNode: HoofNode = {
      freq: x.freq + y.freq,
      char: "-",
      left: x,
      right: y,
    };

    root = newNode;
    // add newHoffNode to the queue
    frqMapArr.push(newNode);

    // sort again to make sure that new nodes are in position
    frqMapArr.sort((a, b) => {
      return a.freq - b.freq;
    });
  }

  root != null ? buildHoofCode(root, "") : null;
}

function generateFrequencyMapArr(s: string) {
  //convert s to lower case
  s = s.toLowerCase();
  // replace space from string
  s = s.replace(/\s+/g, "");
  let sArr = s.split("");
  let setS = new Set(sArr);
  let sfreqArr = [];

  for (const uset of setS) {
    var re = new RegExp(uset, "g");
    let frq = s.match(re);
    let mapNode: HoofNode = {
      freq: frq?.length ? frq.length : 0,
      char: uset,
      left: null,
      right: null,
    };
    sfreqArr.push(mapNode);
  }

  return sfreqArr;
}

function printCode(root: HoofNode, s: string) {
  console.log("printcodeRoot", root);

  // base case; if the left and right are null
  // then its a leaf node and we print
  // the code s generated by traversing the tree.
  if (
    root.left == null &&
    root.right == null &&
    root.char.toLowerCase() != root.char.toUpperCase()
  ) {
    console.log("rut_trace_s", s);

    // c is the character in the node
    console.log(root.char + ":" + s);
    return;
  }

  // if we go to left then add "0" to the code.
  // if we go to the right add"1" to the code.

  // recursive calls for left and
  // right sub-tree of the generated tree.

  // keep going on left on each left add 0 on ech right add 1
  printCode(root.left, s + "0");
  printCode(root.right, s + "1");
}

function buildHoofCode(root: HoofNode, s: string) {
  if (
    root.left == null &&
    root.right == null &&
    root.char.toLowerCase() != root.char.toUpperCase()
  ) {
    hoofCodeMap.set(root.char, s);
    return;
  }

  buildHoofCode(root.left, s + "0");
  buildHoofCode(root.right, s + "1");
}

function decodeHoofCode(_root: any, code: string) {
  if (
    _root.left == null &&
    _root.right == null &&
    _root.char.toLowerCase() != _root.char.toUpperCase()
  ) {
    decoded_string = decoded_string + _root.char;
    if (code.length) {
      decodeHoofCode(root, code);
    } else {
      return decoded_string;
    }
  } else {
    let codeArr = code.split("");
    let pointer = codeArr.shift();
    let newCode = codeArr.join("");

    console.log("codeArr-", codeArr);

    if (pointer == "1") {
      decodeHoofCode(_root.right, newCode);
    } else {
      decodeHoofCode(_root.left, newCode);
    }
  }

  return decoded_string;
}

let map = generateFrequencyMapArr("qbracadabra");
buildHoffTreeAndGenerateHoofCode(map);
console.log("rut", root);

console.log("decoded string --", decodeHoofCode(root, "011100010"));

console.log(hoofCodeMap);
